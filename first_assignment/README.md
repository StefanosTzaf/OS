                                            Δομές της εργασίας

--List: Έχω δημιουργήσει αρχικά μία διπλά συνδεδεμένη λίστα (ώστε στην διαγραφή να μην χρειάζεται
 να διατρέξουμε ολη την λίστα για να βρούμε τον previous node ) η οποία έχει generic μορφη (value = void*)
 μιάς και παρακάτω χρησιμοποιούμε πολλές διαφορετικές λίστες να μην χρειάζεται διαφορετική υλοποίηση.
 Με αυτόν τον τρόπο όμως χρειαζόμαστε και συναρτήσεις που θα δίνονται κάθε φορά από τον χρήστη της συνάρτησης
 πχ. στον Graph για το πως θα συγκρίνονται τα στοιχεία της λιστας (compare) και πως θα διαγράφονται αποδοτικά(destroy).
 Για αυτό χρησιμοποιώ δείκτη σε συναρτήσεις CompareFunc και destroyFunc που έχουν οριστεί στο List.h.

 Τα struct της λίστας δηλώνονται Incomolete στο αρχείο .h .
 Έτσι δεν μπορούν οι χρήστες της συνάρτησης (πχ ο Γράφος ως χρήστης της λιστας) να έχουν πρόσβαση στα πεδία τους και να
 μπορούν να τα μεταβάλουν απευθείας, μόνο μέσω συναρτήσεων εάν χρειαστεί. Έτσι, η λίστα είναι ένα interface που παρέχει 
 κάποιες λειτουργίες ως προς άλλες δομές(Διευκόλυνση στο debugging, αφου επιβεβαιώσουμε οτι η λίστα δουλεύει σωστά
 δεν χρειάζεται να ασχοληθούμε με το πως υλοποιεί τα πράγματα στο εσωτερικό της ξανά).

--Map(υλοποίηση με hash table): Υλοποιώ ένα Map με hash table με separate chaining, στο οποίο θα χρειαστεί 
 για να έχουμε πρόσβαση σε χρόνο Ο(1) αφού η ιδέα είναι να αντιστοιχίζουμε το id του χρήστη σε Graphnodes, 
 έτσι θα έχουμε απευθείας πρόσβαση σε έναν κόμβο χωρίς να χρειαστεί να διατρέξουμε τη λίστα γειτνίασης.
 Επιλέγουμε το hash table το οποίο μέσω ενός hash function αντιστοιχίζει Keys με συγκεκριμένα values σε θέσεις
 στον πίνακα με τέτοιο τρόπο ώστε τα collisions(διαφορετικά κλειδιά να πέφτουν πάνω στην ίδια θέση - τότε 
 δημιουργούμε μια λίστα ) να είναι λίγα άρα στην αναζήτηση χρησιμοποιώντας το hash function μπορουμε να έχουμε 
 πρόσβαση άμεσα στην θέση του πίνακα και να διατρέξουμε της παρούσα λίστα(bucket) η οποία όπως είπαμε
 θα είναι μικρή οπότε amortized time search θα έχουμε O(1).

 To αρχικό capacity του πίνακα θέτεται όσες οι γραμμές του αρχείου *2(στην χειρότερη περίπτωση θα έχει 
 κάθε μία ακμή έναν κόμβο νέο) και για να έχουμε χώρο για Inserts αφού δεν κάνουμε rehashing αλλά
 και για να είναι σχετικά μικρός ο load factor κάνουμε *3

--Γράφος: H δομή του γράφου θα αποθηκεύει τους χρήστες και όλες τις συναλλαγές που έχουν κάνει μεταξύ τους.
 Αρχικά ο Γράφος πρέπει να έχει μία λίστα απο τους κόμβους αυτούς. Ο κάθε κόμβος με την σειρά του έχει το id 
 του και δύο λίστες με ακμές (εισερχόμενες και εξερχόμενες) οι οποίες αναπαριστουν τις συναλλαγές του κόμβου 
 προς κάποιον άλλον κόμβο ή από έναν άλλον κόμβο αντίστοιχα. Η κάθε ακμή με την σειρά της είναι και αυτή ένα struct
 και περιέχει την ημερομηνία συναλλαγης το ποσό συναλλαγής και δύο δείκτες σε graph nodes οι οποίοι υποδεικνύουν 
 τους κόμβους προορισμού και προέλευσης της ακμής αυτής.
 -----------------------------------------------------------------------------------------------------------------

--Λειτουργίες Miris

Γενικά: Τα id των χρηστών τα άφησα ως String γιατί τα είχα υλοποιήσει πριν δω την διευκρύνιση.
Eπίσης η αποθήκευση της εντολής σε 2 μεταβλητές επεξηγείται σε σχόλια στην main(χρειάζεται γιατί στις
εντολές insert και delete οπού μπορούν να προσθεθούν - αφαιρεθούν πολλοί κόμβοι πρέπει πρώτα να ελένξουμε
αν υπάρχει κάποιος προβληματικός και μετά να ξανα διατρέξουμε το 2ο string με την strtok για να πέρνουμε
έναν έναν τους κόμβους που έχεο δώσει ο χρήστης).

Εντολές:

  1: 
    Στην εισαγωγή αρχικά τσεκάρουμε αν κάποις κόμβος υπάρχει στο map. Έπειτα για κάθε κόμβο καλούμε την graphAddNode
    για εισαγωγή στην λίστα και στο map.
  2:
    Στην εισαγωγή ακμών χρησιμοποιώ την addEdge, η οποία όπως αναφέρεται στην εκφώνηση προσθέτει τους κ΄πμβους που δεν 
    υπάρχουν στον γράφο και έπειτα δημιουργεί μια ακμή , και προσθέτει δείκτη στην ακμή και στις δυο λίστες(incoming του destination και
    outgoing του source). Δείκτης χρησιμοποιείται έτσι ώστε να μην έχουμε 2 αντιγραφα της ακμής, ώστε να γλιτώσουμε χώρο αλλα και να υπάρχει
    συμβατότητα μεταξύ των ακμών (αν αλλάξει μία ακμή οι 2 λίστες να βλέπουν στην ίδια).
  3:
    Για την διαγραφή κόμβων και όλων των ακμών που έχουν να κάνουν με τους κόμβους αυτους καλώ την removeGraphNode.
    Η οποία αφαιρεί τον κόμβο από το hash table για να μην υπάρχει σε μελλοντική αναζήτηση, και έπειτα διαγράφει τον
    κόμβο από την λίστα από κόμβους του γράφου. Ουσιαστικά όλη η αποδεύσμευση μνήμης γίνεται στην destroy func της λιστας
    (destroyGraphListNode) η οποία διαγράφει τις δύο λίστες από ακμές εκτός από την απελεύθερωση της μνήμης σχετικά
    με το id του node. Όταν πάνε να διαγραφούν οι ακμές μέσα από την λίστα καλείται η δικία τους destroyfunc 
    destroyEdge η οποία διαγράφει αποδοτικά και απο την outgoing list της πηγής και απο την incoming του προορισμού τον δείκτη 
    στην ακμή αυτή. Όμως καλείται με destroyfunc ορισμένο σε null γιατί δεν θέλουμε να διαγραφεί και το περιεχόμενο του edge 
    (δηλαδή του Value του Listnode) γιατί το διαγράφουμε στην συνάρτηση που προηγείται.
  4:
    Aφού κάνει τους απαραίτητους ελέγχους καλείτην findEdge για να βρει μία ακμή μεταξύ των κόμβων αυτών και έπειτα την διαγράφει.
  5:
    Ψάχνει την ακμή στο outgoing edges του ενός κόμβου με προσπέλαση της λίστας και μεταβάλει τα περιεχόμενα της.
  6:
    Εκτυπώνει την outgoing λίστα του κόμβου
  7:
    Όμοια. Την incoming.
  8:
    Χρησιμοποιώ dfs και εκτπώνω τους κυκλους(για τον κόμβο πχ 2 στο data8-3.txt) που ξεκινάν από τον 2 και καταλήγουν στον 2. 
    Αυτοί είναι και όλοι οι κύκλοι στους οποίους εμπλέκεται ο κόμβος 2. Αφού ψάχνουμε κάθε μονοπάτι μέχρι να φτάσουμε σε visited
    και αν δεν είναι ο 2 σταματάμε αφού θέλουμε απλούς κύκλους(όχι τον ίδιο κόμβο 2 φορές εκτός από τον πρώτο). Για τα ερωτήματα
    με dfs χρησιμοποιούμε μία λίστα που συμπεριφέρεται σαν ουρά , αφου η Insert βάζει στο τέλος της λίστας, και κάνουμε removeLast
    για να τα εκτυπώσουμε με την σειρά που μπηκαν FIFO. Αυτό προφανώς ισχύει αν υπάρχει κύκλος ,αλλιιώς η κάθε αναδρομική κλήση της 
    dfs αφαιρεί τον κόμβο που πρόσθεσε.
  9:
    Παρόμοια λογική μόνο που αν βρεθεί ποσό μικρότερο , η διαδρομή παραλοίπεται και συνεχίζουμε στην επόμενη πιθανή.

  11:
    Η ίδια λογική του dfs χρησιμοποιείται και εδώ απλά έχουμε μιά μεταβλητή που είναι ορισμένη στον σωρό, για να ξέρουμε άν 
    έχει βρεθεί μονοπάτι. Και να έχουν πρόσβαση σε αυτό όλες οι αναδρομικές κλήσεις της dfs.
  12:
    κάνει τα απαραίτητα free.
